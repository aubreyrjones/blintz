grammar Blintz

# ========Program Level Rules==========

    rule blintz_module
        blintz_module_statement*
    end
    
    rule blintz_module_statement
    	_s_ top_level_statement _s_
    end

# =======Top Level Statements==========

    rule top_level_statement
        function_def / import_statement / struct_def
    end

    rule import_statement
        _import _s_ string_literal _s_ ';'
    end
	
	rule function_def
		_def _s_ identifier _s_ parameter_list _s_ statement
	end

    rule struct_def
        _struct _s_ struct_type _s_ struct_body_definition
    end

# ========Struct Statements============

    rule struct_body_definition
        '{' (_s_ struct_body_statement _s_)+ '}'
    end

    rule struct_body_statement
        var_declaration_statement / function_def
    end

# ===========Statements================

    rule statement
        compound_statement / simple_statement
    end 

	rule simple_statement
		(expression_statement / assignment_statement / var_declaration_statement / if_statement / while_statement / return_statement) _s_ ';'
	end

	rule compound_statement
		'{' (_s_ simple_statement _s_)* '}'
	end

	rule expression_statement
		expression
	end

	rule return_statement
		_return _s_ expression?
	end

    rule assignment_statement
        identifier _s_ '=' _s_ expression
    end


# ===========Var Declarations===========

    rule var_declaration_statement
        word_var_declaration / struct_var_declaration
    end

    rule word_var_declaration
        _var_decl _s_ identifier
    end

    rule struct_var_declaration
        _var_decl _s_ struct_type _s_ identifier
    end

    rule _var_decl
        _var _s_ var_decoration
    end

# ===========Conditionals==============
	
	rule if_statement
		_if _s_ '(' _s_ expression _s_ ')' _s_ statement (_s_ elsif_statement)* _s_ else_statement?
	end
	
	rule else_statement
		_else _s_ statement
	end
	
	rule elsif_statement
		_elsif _s_ '(' _s_ expression _s_ ')' _s_ statement
	end

# =============Loops===================

	rule while_statement
		_while _s_ '(' _s_ expression _s_ ')' _s_ statement
	end

# ===========Expressions===============

	rule expression
		numeric_literal
	end

# ===========Functions=================
	
	rule parameter_list
		'(' _s_ (parameter_list / '') _s_ ')' 
	end
	
	rule parameter_list
		identifier _s_ (additional_param _s_)*
	end
	
	rule additional_param
		',' _s_ identifier
	end

# ============Keywords=================

	rule _struct
		('struct' / 'STRUCT') !(keyword_term)
	end

	rule _while
		('while' / 'WHILE') !(keyword_term)
	end

	rule _def
		('def' / 'DEF') !(keyword_term)
	end

	rule _if
		('if' / 'IF') !(keyword_term)
	end
	
	rule _elsif
		('elsif' / 'ELSIF') !(keyword_term)
	end
	
	rule _else
		('else' / 'ELSE') !(keyword_term)
	end
	
	rule _return
		('return' / 'RETURN') !(keyword_term)
	end

    rule _import
        ('import' / 'IMPORT') !(keyword_term)
    end

    rule _var
        ('var' / 'VAR') !(keyword_term)
    end

    rule keyword_term
        (![ \t\n] .)
    end

# ========Var Decorations==============

    rule var_decoration
        _static / ''
    end

    rule _static
        ('static' / 'STATIC') !(keyword_term)
    end
	
# =============Names===================

	rule struct_type
		[A-Z\._]+ [a-zA-Z\._0-9]*
	end

	rule identifier
		'@'? [a-z\._]+ [a-zA-Z\._0-9]*
	end
	
# ============Literals=================
	rule _s_
        (space / comment)*
	end

    rule space
		([ \t\n]*)
    end

    rule comment
        ('/*' (!'*/' .)* '*/') / ('//' (!"\n" .) "\n")
    end

	# A string literal
	rule string_literal
		'"' ('\"' / !'"' .)* '"' {
			def content
				{:type => :string_literal, :token => text_value, :value => elements[1].text_value)}
			end
		}
	end
	
	# A numeric literal term
	rule numeric_literal
		'-'? (hex / decimal) {
			def content
				sign = 1
				if text_value.start_with? '-'
					sign = -1
				end
				{:type => :numeric_literal, :token => text_value, :value => elements[1].value * sign}
			end
		}
	end
	
	# A decimal number.
	rule decimal
		[0-9]+ {
			def value
				text_value.to_i(10)
			end
		}
	end
	
	# A hexadecimal number
	rule hex
		'0x' [0-9a-fA-F]+ {
			def value
				text_value[2..-1].to_i(16)
			end
		}
	end
	
end
