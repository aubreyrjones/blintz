grammar BlintzGrammar

# ========Program Level Rules==========

    rule blintz_module
        blintz_module_statement*
    end
    
    rule blintz_module_statement
    	_s_ top_level_statement _s_
    end

# =======Top Level Statements==========

    rule top_level_statement
        function_def # / import_statement / struct_def
    end

#    rule import_statement
#        _include _s_ string_literal _s_ ';'
#    end
	
	rule function_def
		_def _s_ identifier _s_ parameter_list _s_ statement
	end

    rule struct_def
        _struct _s_ struct_type _s_ struct_body_definition
    end

# ========Struct Statements============

    rule struct_body_definition
        '{' (_s_ struct_body_statement _s_)+ '}'
    end

    rule struct_body_statement
        var_declaration_statement / function_def
    end

# ===========Statements================

    rule statement
        compound_statement / simple_statement
    end 

	rule simple_statement
		(expression_statement / assignment_statement / var_declaration_statement / if_statement / while_statement / return_statement) _s_ ';'
	end

	rule compound_statement
		'{' (_s_ simple_statement _s_)* '}'
	end

	rule expression_statement
		expression
	end

	rule return_statement
		_return _s_ expression?
	end

    rule assignment_statement
        identifier _s_ '=' _s_ expression
    end


# ===========Var Declarations===========

	rule variable_declaration
		simple_decl
	end

	rule simple_decl
		struct_decl / word_decl / array_decl
	end

	rule struct_decl
		_var _s_ type_name (parameter_list / '') _s_ identifier  
	end

	rule word_decl
		_var _s_ identifier
	end
	
	rule array_decl
		_var _s_ expression _s_ identifier 
	end

# ===========Conditionals==============
	
	rule if_statement
		_if _s_ '(' _s_ expression _s_ ')' _s_ statement (_s_ elsif_statement)* _s_ else_statement?
	end
	
	rule else_statement
		_else _s_ statement
	end
	
	rule elsif_statement
		_elsif _s_ '(' _s_ expression _s_ ')' _s_ statement
	end

# =============Loops===================

	rule while_statement
		_while _s_ '(' _s_ expression _s_ ')' _s_ statement next_statement?
	end
	
	rule next_statement
		_next _s_ statement
	end

# ===========Expressions===============

	rule expression
		numeric_literal
	end

# ===========Functions=================
	
	rule parameter_list
		'(' _s_ (parameter_list / '') _s_ ')' 
	end
	
	rule parameter_list
		identifier _s_ (additional_param _s_)*
	end
	
	rule additional_param
		',' _s_ identifier
	end

# ============Keywords=================

    rule _include
        ('include' / 'INCLUDE') !(keyword_term)
    end

	rule _def
		('def' / 'DEF') !(keyword_term)
	end

	rule _struct
		('struct' / 'STRUCT') !(keyword_term)
	end
	
	rule _filter
		('filter' / 'FILTER') !(keyword_term)
	end
	
	rule _as
		('as' / 'AS') !(keyword_term)
	end

	rule _while
		('while' / 'WHILE') !(keyword_term)
	end
	
	rule _next
		('next' / 'NEXT') !(keyword_term)
	end

	rule _if
		('if' / 'IF') !(keyword_term)
	end
	
	rule _elsif
		('elsif' / 'ELSIF') !(keyword_term)
	end
	
	rule _else
		('else' / 'ELSE') !(keyword_term)
	end
	
	rule _return
		('return' / 'RETURN') !(keyword_term)
	end

    rule _var
        ('var' / 'VAR') !(keyword_term)
    end

    rule keyword_term
        (![ \t\n] .)
    end

# =============Names===================

	rule type_name
		[A-Z\._]+ [a-zA-Z\._0-9]*
	end
	
	rule identifier
		'@'? [a-z\._]+ [a-zA-Z\._0-9]*
	end
	
# ============Literals=================
	rule _s_
        space
	end

    rule space
		([ \t\n]*)
    end

    rule comment
        ('/*' (!'*/' .)* '*/') / ('//' (!"\n" .) "\n")
    end

	# A string literal
	rule string_literal
		'"' ('\"' / !'"' .)* '"' {
			def value
				elements[1].text_value[1..-2]
			end
		}
	end
	
	# A numeric literal term
	rule numeric_literal
		'-'? (hex / decimal) {
			def content
				sign = 1
				if text_value.start_with? '-'
					sign = -1
				end
				{:type => :numeric_literal, :token => text_value, :value => elements[1].value * sign}
			end
		}
	end
	
	# A decimal number.
	rule decimal
		[0-9]+ {
			def value
				text_value.to_i(10)
			end
		}
	end
	
	# A hexadecimal number
	rule hex
		'0x' [0-9a-fA-F]+ {
			def value
				text_value[2..-1].to_i(16)
			end
		}
	end
	
end
